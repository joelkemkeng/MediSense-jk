import serial
import time
import threading
import asyncio
import websockets
import logging
import signal
import sys
from typing import Optional

# Configuration du logging pour debug
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('medisense.log', mode='a')
    ]
)
logger = logging.getLogger(__name__)

# D√©claration des variables globales pour stocker les donn√©es
poids: Optional[float] = None
temperature: Optional[float] = None
validation: Optional[int] = None
refValidateCard: int = 310502


# Lock pour la synchronisation des threads
data_lock = threading.Lock()

# Variable pour contr√¥ler l'arr√™t propre du programme
shutdown_event = threading.Event()

# Liste des clients connect√©s
connected_clients = set()

def read_serial_data():
    """Fonction qui lit en continu les donn√©es du port s√©rie"""
    global poids, temperature, validation
    
    # Variables pour les connexions s√©rie
    ser_poids = None
    ser_temperature = None
    ser_validation = None
    
    try:
        logger.info("üîå Tentative de connexion aux ports s√©rie...")
        
        # Tentative de connexion avec gestion d'erreur pour chaque port
        ports_connected = 0
        
        try:
            ser_poids = serial.Serial('/dev/ttyUSB0', 57600, timeout=1)
            logger.info("‚úÖ Connexion r√©ussie au port poids (/dev/ttyUSB0)")
            ports_connected += 1
        except serial.SerialException as e:
            logger.warning(f"‚ö†Ô∏è Port poids non disponible (/dev/ttyUSB0): {e}")
            
        try:
            ser_temperature = serial.Serial('/dev/ttyUSB1', 9600, timeout=1)
            logger.info("‚úÖ Connexion r√©ussie au port temp√©rature (/dev/ttyUSB1)")
            ports_connected += 1
        except serial.SerialException as e:
            logger.warning(f"‚ö†Ô∏è Port temp√©rature non disponible (/dev/ttyUSB1): {e}")
            
        try:
            ser_validation = serial.Serial('/dev/ttyACM0', 9600, timeout=1)
            logger.info("‚úÖ Connexion r√©ussie au port validation (/dev/ttyACM0)")
            ports_connected += 1
        except serial.SerialException as e:
            logger.warning(f"‚ö†Ô∏è Port validation non disponible (/dev/ttyACM0): {e}")
        
        # Mode simulation si aucun port n'est disponible
        simulate_data = (ports_connected == 0)
        
        if simulate_data:
            logger.warning("‚ö†Ô∏è Aucun port s√©rie disponible! D√©marrage en mode SIMULATION...")
        else:
            logger.info(f"‚úÖ {ports_connected} port(s) s√©rie connect√©(s)")
            
        time.sleep(2)  # Pause pour permettre aux ports de s'initialiser
        logger.info("üöÄ D√©but de la lecture des donn√©es...")

        # Compteur pour la simulation
        counter = 0
        last_validation_time = 0

        # Boucle infinie pour lire les donn√©es en continu
        while not shutdown_event.is_set():
            try:
                current_time = time.time()
                
                # Mode simulation si aucun port n'est disponible
                if simulate_data:
                    counter += 1
                    with data_lock:
                        # Simulation de donn√©es r√©alistes
                        poids = round(70.5 + (counter % 20) * 0.1, 1)  # 70.5 √† 72.4 kg
                        temperature = round(36.5 + (counter % 8) * 0.05, 1)  # 36.5 √† 36.85¬∞C
                        
                        # Validation toutes les 30 secondes environ
                        if current_time - last_validation_time > 30:
                            validation = refValidateCard
                            last_validation_time = current_time
                            logger.info(f"‚úÖ [SIMULATION] Validation g√©n√©r√©e: {validation}")
                    
                    if counter % 10 == 0:  # Log toutes les 10 it√©rations
                        logger.info(f"üìä [SIMULATION] Poids: {poids}kg, Temp√©rature: {temperature}¬∞C")
                    
                    time.sleep(2)  # 2 secondes en mode simulation
                    continue

                # Lecture r√©elle des ports s√©rie
                data_received = False
                
                # Lecture du poids
                if ser_poids and ser_poids.is_open:
                    try:
                        if ser_poids.in_waiting > 0:
                            data = ser_poids.readline().decode('utf-8', errors='ignore').strip()
                            if data and data.replace('.', '').replace('-', '').isdigit():
                                new_poids = float(data)
                                if 0 <= new_poids <= 500:  # Validation de plausibilit√©
                                    with data_lock:
                                        poids = round(new_poids, 1)
                                    logger.info(f"‚öñÔ∏è Poids re√ßu: {poids} Kg")
                                    data_received = True
                    except Exception as e:
                        logger.error(f"‚ùå Erreur lecture poids: {e}")

                # Lecture de la temp√©rature
                if ser_temperature and ser_temperature.is_open:
                    try:
                        if ser_temperature.in_waiting > 0:
                            data1 = ser_temperature.readline().decode('utf-8', errors='ignore').strip()
                            if data1 and data1.replace('.', '').replace('-', '').isdigit():
                                new_temperature = float(data1)
                                if 0 <= new_temperature <= 50:  # Validation de plausibilit√©
                                    with data_lock:
                                        temperature = round(new_temperature, 1)
                                    logger.info(f"üå°Ô∏è Temp√©rature re√ßue: {temperature}¬∞C")
                                    data_received = True
                    except Exception as e:
                        logger.error(f"‚ùå Erreur lecture temp√©rature: {e}")

                # Lecture de la validation
                if ser_validation and ser_validation.is_open:
                    try:
                        if ser_validation.in_waiting > 0:
                            data3 = ser_validation.readline().decode('utf-8', errors='ignore').strip()
                            #if data3.isdigit():
                            new_validation = int(data3)
                            if new_validation == refValidateCard:
                                with data_lock:
                                    validation = new_validation
                                logger.info(f"‚úÖ Validation re√ßue: {validation}")
                                data_received = True
                            else:
                                logger.warning(f"‚ö†Ô∏è Code de validation incorrect: {new_validation}")
                    except Exception as e:
                        logger.error(f"‚ùå Erreur lecture validation: {e}")
                
                # Pause adaptative
                time.sleep(0.05 if data_received else 0.2)
                        
            except Exception as e:
                logger.error(f"‚ùå Erreur lors de la lecture s√©rie: {e}")
                time.sleep(1)
                
    except Exception as e:
        logger.error(f"‚ùå Erreur critique dans read_serial_data: {e}")
    finally:
        # Fermeture propre des connexions s√©rie
        for ser_name, ser in [("poids", ser_poids), ("temp√©rature", ser_temperature), ("validation", ser_validation)]:
            if ser and hasattr(ser, 'is_open') and ser.is_open:
                try:
                    ser.close()
                    logger.info(f"üîå Port {ser_name} ferm√©")
                except Exception as e:
                    logger.error(f"‚ùå Erreur fermeture port {ser_name}: {e}")
        logger.info("üîå Toutes les connexions s√©rie ferm√©es")

# ‚úÖ CORRECTION PRINCIPALE: Signature de fonction corrig√©e
async def socket_server(websocket):
    """Fonction pour g√©rer les connexions WebSocket - SIGNATURE CORRIG√âE"""
    global poids, temperature, validation
    
    client_address = f"{websocket.remote_address[0]}:{websocket.remote_address[1]}"
    logger.info(f"üåê Nouvelle connexion WebSocket de {client_address}")
    
    # Ajouter le client √† la liste
    connected_clients.add(websocket)
    
    try:
        # Message de bienvenue
        await websocket.send("Connection au serveur effectu√©e")
        logger.info(f"‚úÖ Message de bienvenue envoy√© √† {client_address}")

        # Boucle pour √©couter les messages du client
        async for message in websocket:
            logger.info(f"üì® Message de {client_address}: {message}")
            
            try:
                response = ""
                
                # Gestion des commandes
                if message == "get-poid":
                    with data_lock:
                        if poids is not None and poids > 0:
                            response = f"Poids:{poids}"
                        else:
                            response = "Poids:0"

                elif message == "get-temperature":
                    with data_lock:
                        if temperature is not None and temperature > 0:
                            response = f"Temp√©rature:{temperature}"
                        else:
                            response = "Temp√©rature:0"

                elif message == "get-validation":
                    with data_lock:
                        if validation is not None and validation == refValidateCard:
                            response = f"Validation:{validation}"
                            validation = None  # R√©initialiser apr√®s envoi
                        else:
                            response = "Validation:0"

                elif message == "reset-data":
                    with data_lock:
                        poids = None
                        temperature = None
                        validation = None
                    response = "Reset:OK"

                elif message == "all-mesure":
                    # Cr√©ation d'une cha√Æne avec toutes les mesures
                    mesures = []
                    
                    with data_lock:
                        # Poids
                        if poids is not None and poids > 0:
                            mesures.append(f"poids:{poids}")
                        else:
                            mesures.append("poids:0")
                        
                        # Temp√©rature
                        if temperature is not None and temperature > 0:
                            mesures.append(f"temperature:{temperature}")
                        else:
                            mesures.append("temperature:0")
                        
                        # Validation
                        if validation is not None and validation == refValidateCard:
                            mesures.append(f"validation:{validation}")
                            validation = None  # R√©initialiser apr√®s envoi
                        else:
                            mesures.append("validation:0")
                    
                    response = "All-Mesure:" + ":".join(mesures)

                elif message == "ping":
                    response = "pong"
                
                elif message == "status":
                    # Commande de statut du serveur
                    with data_lock:
                        response = f"Status:clients={len(connected_clients)},poids={poids},temp={temperature},valid={validation}"
                
                else:
                    response = f"Commande inconnue: {message}"
                    logger.warning(f"‚ö†Ô∏è Commande inconnue de {client_address}: {message}")
                
                # Envoyer la r√©ponse
                await websocket.send(response)
                logger.info(f"üì§ Envoy√© √† {client_address}: {response}")
                    
            except websockets.exceptions.ConnectionClosed:
                logger.info(f"üîå Connexion ferm√©e par {client_address}")
                break
            except Exception as e:
                logger.error(f"‚ùå Erreur traitement message de {client_address}: {e}")
                try:
                    await websocket.send(f"Erreur serveur: {str(e)}")
                except:
                    pass  # Connexion peut √™tre ferm√©e
                
    except websockets.exceptions.ConnectionClosed:
        logger.info(f"üîå Client {client_address} d√©connect√©")
    except Exception as e:
        logger.error(f"‚ùå Erreur dans socket_server pour {client_address}: {e}")
    finally:
        # Retirer le client de la liste
        connected_clients.discard(websocket)
        logger.info(f"üîö Fin de session avec {client_address} (Clients restants: {len(connected_clients)})")

# ‚úÖ CORRECTION: Fonction de d√©marrage du serveur WebSocket simplifi√©e
async def start_websocket_server():
    """D√©marrage du serveur WebSocket"""
    logger.info("üöÄ D√©marrage du serveur WebSocket sur 127.0.0.1:8765")
    try:
        # Cr√©er le serveur - SIGNATURE CORRIG√âE sans 'path'
        async with websockets.serve(
            socket_server,  # Fonction handler sans param√®tre 'path'
            "127.0.0.1", 
            8765,
            ping_interval=30,  # Ping toutes les 30 secondes
            ping_timeout=10,   # Timeout ping 10 secondes
            close_timeout=10   # Timeout fermeture 10 secondes
        ):
            logger.info("‚úÖ Serveur WebSocket d√©marr√© avec succ√®s")
            logger.info(f"üì° En √©coute sur ws://127.0.0.1:8765")
            
            # Attendre ind√©finiment
            await asyncio.Future()  # Run forever
        
    except Exception as e:
        logger.error(f"‚ùå Erreur serveur WebSocket: {e}")
        raise

def run_websocket_server():
    """Fonction pour ex√©cuter le serveur WebSocket dans un thread"""
    try:
        # Cr√©er une nouvelle boucle d'√©v√©nements pour ce thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Ex√©cuter le serveur WebSocket
        loop.run_until_complete(start_websocket_server())
        
    except Exception as e:
        logger.error(f"‚ùå Erreur dans run_websocket_server: {e}")
    finally:
        try:
            loop.close()
        except:
            pass

def signal_handler(signum, frame):
    """Gestionnaire de signal pour arr√™t propre"""
    logger.info(f"üõë Signal {signum} re√ßu, arr√™t du programme...")
    shutdown_event.set()
    
    # Fermer toutes les connexions WebSocket
    for client in connected_clients.copy():
        try:
            asyncio.create_task(client.close())
        except:
            pass
    
    sys.exit(0)

def main():
    """Point d'entr√©e principal"""
    logger.info("=" * 60)
    logger.info("üè• ===== D√âMARRAGE DE MEDISENSE PRO v2.0 =====")
    logger.info("=" * 60)
    
    # Enregistrer les gestionnaires de signaux
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        # Lancement du thread de lecture s√©rie
        logger.info("üîß Lancement du thread de lecture s√©rie...")
        serial_thread = threading.Thread(
            target=read_serial_data, 
            daemon=True, 
            name="SerialReader"
        )
        serial_thread.start()
        logger.info("‚úÖ Thread s√©rie d√©marr√©")

        # Lancement du thread serveur WebSocket
        logger.info("üåê Lancement du thread WebSocket...")
        socket_thread = threading.Thread(
            target=run_websocket_server, 
            daemon=True, 
            name="WebSocketServer"
        )
        socket_thread.start()
        logger.info("‚úÖ Thread WebSocket d√©marr√©")

        logger.info("üéØ Tous les services sont actifs!")
        logger.info("üìä Rafra√Æchissement automatique toutes les 2 secondes c√¥t√© client")
        logger.info("üåê WebSocket accessible sur ws://127.0.0.1:8765")
        logger.info("‚èπÔ∏è  Appuyez sur Ctrl+C pour arr√™ter")
        logger.info("-" * 60)
        
        # Maintenir le programme principal en vie avec monitoring
        heartbeat_counter = 0
        while not shutdown_event.is_set():
            time.sleep(10)  # Heartbeat toutes les 10 secondes
            heartbeat_counter += 1
            
            # V√©rifier l'√©tat des threads
            if not serial_thread.is_alive():
                logger.warning("‚ö†Ô∏è Thread s√©rie arr√™t√©, red√©marrage...")
                serial_thread = threading.Thread(
                    target=read_serial_data, 
                    daemon=True, 
                    name="SerialReader"
                )
                serial_thread.start()
                
            if not socket_thread.is_alive():
                logger.warning("‚ö†Ô∏è Thread WebSocket arr√™t√©, red√©marrage...")
                socket_thread = threading.Thread(
                    target=run_websocket_server, 
                    daemon=True, 
                    name="WebSocketServer"
                )
                socket_thread.start()
            
            # Log de status toutes les minutes (6 * 10 secondes)
            if heartbeat_counter % 6 == 0:
                with data_lock:
                    logger.info(
                        f"üíì Status: Clients={len(connected_clients)}, "
                        f"Poids={poids}, Temp={temperature}, Valid={validation}"
                    )
            
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è Arr√™t demand√© par l'utilisateur (Ctrl+C)")
    except Exception as e:
        logger.error(f"‚ùå Erreur critique dans main: {e}")
    finally:
        logger.info("üõë Arr√™t en cours...")
        shutdown_event.set()
        time.sleep(2)  # Laisser le temps aux threads de se terminer
        logger.info("‚úÖ Programme termin√© proprement")
        logger.info("=" * 60)

if __name__ == "__main__":
    main()