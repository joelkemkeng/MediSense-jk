import serial
import time
import threading
import asyncio
import websockets
import logging
import signal
import sys
import glob
from typing import Optional, Dict, Any

# Configuration du logging pour debug
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('medisense.log', mode='a')
    ]
)
logger = logging.getLogger(__name__)

# D√©claration des variables globales pour stocker les donn√©es
sensor_data: Dict[str, Any] = {
    'poids': None,
    'temperature': None,
    'temp': None,  # Alias pour temperature
    'validation': None,
    'card': None,  # Alias pour validation
    'taille': None,
    'size': None,  # Alias pour taille
}

# Configuration des capteurs avec validation
SENSOR_CONFIG = {
    'poids': {
        'min_value': 0,
        'max_value': 500,
        'unit': 'kg',
        'precision': 1,
        'aliases': ['weight', 'masse']
    },
    'temperature': {
        'min_value': 0,
        'max_value': 50,
        'unit': '¬∞C',
        'precision': 1,
        'aliases': ['temp']
    },
    'temp': {
        'min_value': 0,
        'max_value': 50,
        'unit': '¬∞C',
        'precision': 1,
        'aliases': ['temperature']
    },
    'validation': {
        'expected_value': 310502,
        'unit': '',
        'precision': 0,
        'aliases': ['card', 'valid']
    },
    'card': {
        'expected_value': 310502,
        'unit': '',
        'precision': 0,
        'aliases': ['validation', 'valid']
    },
    'taille': {
        'min_value': 0.5,
        'max_value': 3.0,
        'unit': 'm',
        'precision': 2,
        'aliases': ['size', 'height']
    },
    'size': {
        'min_value': 0.5,
        'max_value': 3.0,
        'unit': 'm',
        'precision': 2,
        'aliases': ['taille', 'height']
    }
}

# Code de r√©f√©rence pour la validation
refValidateCard: int = 310502

# Lock pour la synchronisation des threads
data_lock = threading.Lock()

# Variable pour contr√¥ler l'arr√™t propre du programme
shutdown_event = threading.Event()

# Liste des clients connect√©s
connected_clients = set()

# Dictionnaire des ports actifs
active_ports: Dict[str, serial.Serial] = {}

def discover_serial_ports():
    """
    D√©couvre automatiquement tous les ports s√©rie disponibles
    Returns: Liste des ports s√©rie d√©tect√©s
    """
    logger.info("üîç D√©couverte automatique des ports s√©rie...")
    
    # Types de ports √† scanner
    port_patterns = [
        '/dev/ttyUSB*',
        '/dev/ttyACM*', 
        '/dev/ttyS*',
        '/dev/ttyAMA*'
    ]
    
    available_ports = []
    
    for pattern in port_patterns:
        ports = glob.glob(pattern)
        available_ports.extend(sorted(ports))
    
    # Filtrer les ports syst√®me non utilisables
    filtered_ports = []
    for port in available_ports:
        try:
            # Test rapide d'ouverture
            test_ser = serial.Serial(port, 9600, timeout=0.1)
            test_ser.close()
            filtered_ports.append(port)
            logger.info(f"üì° Port d√©tect√©: {port}")
        except (serial.SerialException, PermissionError) as e:
            logger.debug(f"‚ö†Ô∏è Port {port} non accessible: {e}")
    
    logger.info(f"‚úÖ {len(filtered_ports)} port(s) s√©rie utilisable(s) trouv√©(s)")
    return filtered_ports

def connect_to_ports(ports_list):
    """
    √âtablit les connexions avec tous les ports disponibles
    Args: ports_list - Liste des ports √† connecter
    Returns: Dictionnaire des connexions √©tablies
    """
    logger.info("üîå Connexion aux ports s√©rie...")
    
    connections = {}
    
    # Baudrates courants √† tester
    baudrates = [9600, 57600, 115200, 38400, 19200]
    
    for port in ports_list:
        port_name = port.split('/')[-1]  # Extraire le nom du port
        
        for baudrate in baudrates:
            try:
                ser = serial.Serial(port, baudrate, timeout=1)
                connections[port_name] = {
                    'serial': ser,
                    'port_path': port,
                    'baudrate': baudrate,
                    'last_data': None,
                    'error_count': 0
                }
                logger.info(f"‚úÖ {port_name} connect√© √† {baudrate} baud")
                break  # Connexion r√©ussie, arr√™ter les tests de baudrate
                
            except serial.SerialException as e:
                logger.debug(f"‚ùå √âchec connexion {port} @ {baudrate}: {e}")
                continue
        
        if port_name not in connections:
            logger.warning(f"‚ö†Ô∏è Impossible de connecter {port}")
    
    logger.info(f"üéØ {len(connections)} connexion(s) √©tablie(s)")
    return connections

def parse_sensor_data(raw_data: str, port_name: str) -> tuple:
    """
    Parse les donn√©es re√ßues d'un capteur selon le format pr√©fixe:valeur
    Args: 
        raw_data - Donn√©es brutes re√ßues
        port_name - Nom du port source
    Returns: (sensor_type, value, success)
    """
    try:
        # Nettoyer les donn√©es
        data = raw_data.strip()
        
        if not data:
            return None, None, False
        
        # V√©rifier le format pr√©fixe:valeur
        if ':' not in data:
            logger.debug(f"üì• {port_name}: Format non reconnu: '{data}'")
            return None, None, False
        
        # S√©parer pr√©fixe et valeur
        parts = data.split(':', 1)  # Split seulement sur le premier ':'
        if len(parts) != 2:
            logger.debug(f"üì• {port_name}: Format invalide: '{data}'")
            return None, None, False
        
        sensor_type = parts[0].lower().strip()
        value_str = parts[1].strip()
        
        # V√©rifier si le type de capteur est connu
        if sensor_type not in SENSOR_CONFIG:
            # V√©rifier les aliases
            found = False
            for main_type, config in SENSOR_CONFIG.items():
                if sensor_type in config.get('aliases', []):
                    sensor_type = main_type
                    found = True
                    break
            
            if not found:
                logger.debug(f"üì• {port_name}: Type capteur inconnu: '{sensor_type}'")
                return None, None, False
        
        # Convertir la valeur selon le type
        config = SENSOR_CONFIG[sensor_type]
        
        try:
            if sensor_type in ['validation', 'card']:
                # Pour la validation, convertir en entier
                value = int(float(value_str))  # float puis int pour g√©rer "310502.0"
            else:
                # Pour les autres, convertir en float
                value = float(value_str)
                # Appliquer la pr√©cision
                value = round(value, config.get('precision', 1))
        
        except ValueError as e:
            logger.warning(f"‚ùå {port_name}: Impossible de convertir '{value_str}': {e}")
            return None, None, False
        
        logger.debug(f"üìä {port_name}: {sensor_type} = {value}")
        return sensor_type, value, True
        
    except Exception as e:
        logger.error(f"‚ùå Erreur parsing donn√©es de {port_name}: {e}")
        return None, None, False

def validate_sensor_value(sensor_type: str, value) -> bool:
    """
    Valide une valeur de capteur selon sa configuration
    Args:
        sensor_type - Type du capteur
        value - Valeur √† valider
    Returns: True si valide, False sinon
    """
    if sensor_type not in SENSOR_CONFIG:
        return False
    
    config = SENSOR_CONFIG[sensor_type]
    
    try:
        if sensor_type in ['validation', 'card']:
            # Validation sp√©ciale pour les codes
            expected = config.get('expected_value', refValidateCard)
            return value == expected
        else:
            # Validation par plage pour les autres capteurs
            min_val = config.get('min_value', float('-inf'))
            max_val = config.get('max_value', float('inf'))
            return min_val <= value <= max_val
    
    except Exception as e:
        logger.error(f"‚ùå Erreur validation {sensor_type}: {e}")
        return False

def update_sensor_data(sensor_type: str, value, port_name: str):
    """
    Met √† jour les donn√©es globales des capteurs
    Args:
        sensor_type - Type du capteur
        value - Nouvelle valeur
        port_name - Port source
    """
    global sensor_data
    
    if not validate_sensor_value(sensor_type, value):
        logger.warning(f"‚ö†Ô∏è {port_name}: Valeur {sensor_type}={value} hors limites")
        return False
    
    with data_lock:
        # Mettre √† jour la valeur principale
        sensor_data[sensor_type] = value
        
        # Mettre √† jour les aliases si n√©cessaire
        config = SENSOR_CONFIG.get(sensor_type, {})
        for alias in config.get('aliases', []):
            if alias in sensor_data:
                sensor_data[alias] = value
        
        # Log de mise √† jour
        unit = config.get('unit', '')
        logger.info(f"üìä {sensor_type.capitalize()}: {value}{unit} (depuis {port_name})")
    
    return True

def read_serial_data():
    """Fonction principale qui lit en continu les donn√©es de tous les ports s√©rie"""
    logger.info("üöÄ D√©marrage de la lecture des donn√©es s√©rie...")
    
    # D√©couvrir les ports disponibles
    available_ports = discover_serial_ports()
    
    if not available_ports:
        logger.warning("‚ö†Ô∏è Aucun port s√©rie disponible! D√©marrage en mode SIMULATION...")
        run_simulation_mode()
        return
    
    # √âtablir les connexions
    connections = connect_to_ports(available_ports)
    
    if not connections:
        logger.warning("‚ö†Ô∏è Aucune connexion √©tablie! D√©marrage en mode SIMULATION...")
        run_simulation_mode()
        return
    
    logger.info(f"‚úÖ Lecture d√©marr√©e sur {len(connections)} port(s)")
    
    # Boucle principale de lecture
    while not shutdown_event.is_set():
        try:
            data_received = False
            
            # Lire chaque port connect√©
            for port_name, conn_info in connections.items():
                ser = conn_info['serial']
                
                try:
                    if not ser.is_open:
                        continue
                    
                    # Lire les donn√©es disponibles
                    if ser.in_waiting > 0:
                        raw_data = ser.readline().decode('utf-8', errors='ignore').strip()
                        
                        if raw_data:
                            # Parser les donn√©es
                            sensor_type, value, success = parse_sensor_data(raw_data, port_name)
                            
                            if success and sensor_type and value is not None:
                                # Mettre √† jour les donn√©es
                                if update_sensor_data(sensor_type, value, port_name):
                                    data_received = True
                                    conn_info['last_data'] = time.time()
                                    conn_info['error_count'] = 0
                            else:
                                logger.debug(f"üì• {port_name}: Donn√©es ignor√©es: '{raw_data}'")
                
                except serial.SerialException as e:
                    conn_info['error_count'] += 1
                    logger.error(f"‚ùå Erreur lecture {port_name}: {e}")
                    
                    # Reconnecter si trop d'erreurs
                    if conn_info['error_count'] > 5:
                        logger.warning(f"üîÑ Tentative de reconnexion {port_name}...")
                        try:
                            ser.close()
                            time.sleep(1)
                            new_ser = serial.Serial(conn_info['port_path'], conn_info['baudrate'], timeout=1)
                            conn_info['serial'] = new_ser
                            conn_info['error_count'] = 0
                            logger.info(f"‚úÖ {port_name} reconnect√©")
                        except Exception as reconnect_error:
                            logger.error(f"‚ùå √âchec reconnexion {port_name}: {reconnect_error}")
                
                except Exception as e:
                    logger.error(f"‚ùå Erreur inattendue {port_name}: {e}")
            
            # Pause adaptative
            time.sleep(0.05 if data_received else 0.2)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur critique dans la boucle de lecture: {e}")
            time.sleep(1)
    
    # Fermeture propre des connexions
    logger.info("üîå Fermeture des connexions s√©rie...")
    for port_name, conn_info in connections.items():
        try:
            if conn_info['serial'].is_open:
                conn_info['serial'].close()
                logger.info(f"üîå {port_name} ferm√©")
        except Exception as e:
            logger.error(f"‚ùå Erreur fermeture {port_name}: {e}")

def run_simulation_mode():
    """Mode simulation avec donn√©es fictives"""
    logger.info("üé≠ Mode SIMULATION activ√©")
    
    counter = 0
    last_validation_time = 0
    
    while not shutdown_event.is_set():
        try:
            current_time = time.time()
            counter += 1
            
            with data_lock:
                # Simulation de donn√©es r√©alistes
                sensor_data['poids'] = round(70.5 + (counter % 20) * 0.1, 1)
                sensor_data['temperature'] = round(36.5 + (counter % 8) * 0.05, 1) 
                sensor_data['temp'] = sensor_data['temperature']  # Alias
                
                # Validation toutes les 30 secondes
                if current_time - last_validation_time > 30:
                    sensor_data['validation'] = refValidateCard
                    sensor_data['card'] = refValidateCard  # Alias
                    last_validation_time = current_time
                    logger.info(f"‚úÖ [SIMULATION] Validation g√©n√©r√©e: {refValidateCard}")
            
            # Log p√©riodique
            if counter % 10 == 0:
                with data_lock:
                    logger.info(f"üìä [SIMULATION] Poids: {sensor_data['poids']}kg, "
                              f"Temp√©rature: {sensor_data['temperature']}¬∞C")
            
            time.sleep(2)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur en mode simulation: {e}")
            time.sleep(1)

async def socket_server(websocket):
    """Fonction pour g√©rer les connexions WebSocket"""
    client_address = f"{websocket.remote_address[0]}:{websocket.remote_address[1]}"
    logger.info(f"üåê Nouvelle connexion WebSocket de {client_address}")
    
    connected_clients.add(websocket)
    
    try:
        await websocket.send("Connection au serveur effectu√©e")
        logger.info(f"‚úÖ Message de bienvenue envoy√© √† {client_address}")

        async for message in websocket:
            logger.debug(f"üì® Message de {client_address}: {message}")
            
            try:
                response = ""
                
                # Gestion des commandes
                if message == "get-poid":
                    with data_lock:
                        value = sensor_data.get('poids')
                        response = f"Poids:{value}" if value is not None and value > 0 else "Poids:0"

                elif message == "get-temperature":
                    with data_lock:
                        value = sensor_data.get('temperature') or sensor_data.get('temp')
                        response = f"Temp√©rature:{value}" if value is not None and value > 0 else "Temp√©rature:0"

                elif message == "get-validation":
                    with data_lock:
                        value = sensor_data.get('validation') or sensor_data.get('card')
                        if value == refValidateCard:
                            response = f"Validation:{value}"
                            # R√©initialiser apr√®s envoi
                            sensor_data['validation'] = None
                            sensor_data['card'] = None
                        else:
                            response = "Validation:0"

                elif message == "get-taille":
                    with data_lock:
                        value = sensor_data.get('taille') or sensor_data.get('size')
                        response = f"Taille:{value}" if value is not None and value > 0 else "Taille:0"

                elif message == "reset-data":
                    with data_lock:
                        for key in sensor_data:
                            sensor_data[key] = None
                    response = "Reset:OK"
                    logger.info(f"üîÑ Donn√©es r√©initialis√©es par {client_address}")

                elif message == "all-mesure":
                    mesures = []
                    
                    with data_lock:
                        # Poids
                        poids_val = sensor_data.get('poids')
                        mesures.append(f"poids:{poids_val}" if poids_val is not None and poids_val > 0 else "poids:0")
                        
                        # Temp√©rature
                        temp_val = sensor_data.get('temperature') or sensor_data.get('temp')
                        mesures.append(f"temperature:{temp_val}" if temp_val is not None and temp_val > 0 else "temperature:0")
                        
                        # Taille
                        taille_val = sensor_data.get('taille') or sensor_data.get('size')
                        mesures.append(f"taille:{taille_val}" if taille_val is not None and taille_val > 0 else "taille:0")
                        
                        # Validation
                        valid_val = sensor_data.get('validation') or sensor_data.get('card')
                        if valid_val == refValidateCard:
                            mesures.append(f"validation:{valid_val}")
                            # R√©initialiser apr√®s envoi
                            sensor_data['validation'] = None
                            sensor_data['card'] = None
                        else:
                            mesures.append("validation:0")
                    
                    response = "All-Mesure:" + ":".join(mesures)

                elif message == "ping":
                    response = "pong"

                elif message == "status":
                    with data_lock:
                        response = f"Status:clients={len(connected_clients)},sensors={len([k for k, v in sensor_data.items() if v is not None])}"

                elif message == "get-sensors":
                    # Nouvelle commande pour lister tous les capteurs d√©tect√©s
                    with data_lock:
                        active_sensors = [k for k, v in sensor_data.items() if v is not None]
                        response = f"Sensors:{','.join(active_sensors)}"

                else:
                    response = f"Commande inconnue: {message}"
                    logger.warning(f"‚ö†Ô∏è Commande inconnue de {client_address}: {message}")
                
                await websocket.send(response)
                logger.debug(f"üì§ Envoy√© √† {client_address}: {response}")
                    
            except websockets.exceptions.ConnectionClosed:
                logger.info(f"üîå Connexion ferm√©e par {client_address}")
                break
            except Exception as e:
                logger.error(f"‚ùå Erreur traitement message de {client_address}: {e}")
                try:
                    await websocket.send(f"Erreur serveur: {str(e)}")
                except:
                    pass
                
    except websockets.exceptions.ConnectionClosed:
        logger.info(f"üîå Client {client_address} d√©connect√©")
    except Exception as e:
        logger.error(f"‚ùå Erreur dans socket_server pour {client_address}: {e}")
    finally:
        connected_clients.discard(websocket)
        logger.info(f"üîö Fin de session avec {client_address} (Clients restants: {len(connected_clients)})")

async def start_websocket_server():
    """D√©marrage du serveur WebSocket"""
    logger.info("üöÄ D√©marrage du serveur WebSocket sur 127.0.0.1:8765")
    try:
        async with websockets.serve(
            socket_server,
            "127.0.0.1", 
            8765,
            ping_interval=30,
            ping_timeout=10,
            close_timeout=10
        ):
            logger.info("‚úÖ Serveur WebSocket d√©marr√© avec succ√®s")
            logger.info(f"üì° En √©coute sur ws://127.0.0.1:8765")
            await asyncio.Future()  # Run forever
        
    except Exception as e:
        logger.error(f"‚ùå Erreur serveur WebSocket: {e}")
        raise

def run_websocket_server():
    """Fonction pour ex√©cuter le serveur WebSocket dans un thread"""
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(start_websocket_server())
    except Exception as e:
        logger.error(f"‚ùå Erreur dans run_websocket_server: {e}")
    finally:
        try:
            loop.close()
        except:
            pass

def signal_handler(signum):
    """Gestionnaire de signal pour arr√™t propre"""
    logger.info(f"üõë Signal {signum} re√ßu, arr√™t du programme...")
    shutdown_event.set()
    
    for client in connected_clients.copy():
        try:
            asyncio.create_task(client.close())
        except:
            pass
    
    sys.exit(0)

def main():
    """Point d'entr√©e principal"""
    logger.info("=" * 60)
    logger.info("üè• ===== D√âMARRAGE DE MEDISENSE PRO v3.0 =====")
    logger.info("=" * 60)
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        # Lancement du thread de lecture s√©rie
        logger.info("üîß Lancement du thread de lecture s√©rie avec d√©tection automatique...")
        serial_thread = threading.Thread(
            target=read_serial_data, 
            daemon=True, 
            name="SerialReader"
        )
        serial_thread.start()
        logger.info("‚úÖ Thread s√©rie d√©marr√©")

        # Lancement du thread serveur WebSocket
        logger.info("üåê Lancement du thread WebSocket...")
        socket_thread = threading.Thread(
            target=run_websocket_server, 
            daemon=True, 
            name="WebSocketServer"
        )
        socket_thread.start()
        logger.info("‚úÖ Thread WebSocket d√©marr√©")

        logger.info("üéØ Tous les services sont actifs!")
        logger.info("üîç D√©tection automatique des capteurs par pr√©fixe activ√©e")
        logger.info("üìä Format attendu: 'type:valeur' (ex: temp:36.5, poids:70.2)")
        logger.info("üåê WebSocket accessible sur ws://127.0.0.1:8765")
        logger.info("‚èπÔ∏è  Appuyez sur Ctrl+C pour arr√™ter")
        logger.info("-" * 60)
        
        # Maintenir le programme principal en vie avec monitoring
        heartbeat_counter = 0
        while not shutdown_event.is_set():
            time.sleep(10)
            heartbeat_counter += 1
            
            # V√©rifier l'√©tat des threads
            if not serial_thread.is_alive():
                logger.warning("‚ö†Ô∏è Thread s√©rie arr√™t√©, red√©marrage...")
                serial_thread = threading.Thread(
                    target=read_serial_data, 
                    daemon=True, 
                    name="SerialReader"
                )
                serial_thread.start()
                
            if not socket_thread.is_alive():
                logger.warning("‚ö†Ô∏è Thread WebSocket arr√™t√©, red√©marrage...")
                socket_thread = threading.Thread(
                    target=run_websocket_server, 
                    daemon=True, 
                    name="WebSocketServer"
                )
                socket_thread.start()
            
            # Log de status toutes les minutes
            if heartbeat_counter % 6 == 0:
                with data_lock:
                    active_sensors = [k for k, v in sensor_data.items() if v is not None]
                    logger.info(f"üíì Status: Clients={len(connected_clients)}, "
                              f"Capteurs actifs={len(active_sensors)}, "
                              f"Donn√©es: {dict((k, v) for k, v in sensor_data.items() if v is not None)}")
            
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è Arr√™t demand√© par l'utilisateur (Ctrl+C)")
    except Exception as e:
        logger.error(f"‚ùå Erreur critique dans main: {e}")
    finally:
        logger.info("üõë Arr√™t en cours...")
        shutdown_event.set()
        time.sleep(2)
        logger.info("‚úÖ Programme termin√© proprement")
        logger.info("=" * 60)

if __name__ == "__main__":
    main()